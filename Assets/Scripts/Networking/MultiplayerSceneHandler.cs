using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using DataTypeUtils;
using System.Diagnostics;

/*
    This controls all multiplayer scene specific "game related stuff"
    ..spawning players for example, etc..
*/
public class MultiplayerSceneHandler : MonoBehaviour
{
    private bool isGameManagerInitialized = false;

    private WaveController waveController;
    
    // Modifies "local" player objects depending on the server's connected users list
    // May remove or add players to the scene..
    public static bool ShouldUpdateLocalPlayersList { get; set; }
    private bool gameStarted = false;

    private bool isExiting = false;

    void Start()
    {
        MultiplayerSceneProperties.Instance.currentPlayerList = new List<byte>();
        MultiplayerSceneProperties.Instance.previousPlayerList = new List<byte>();

        GameObject waveControllerOBJ = GameObject.Find("WaveController");
        if (waveControllerOBJ != null)
            waveController = waveControllerOBJ.GetComponent<WaveController>();
        
    }

    // Finds all alive enemy game objects from wave controller's spawners
    List<GameObject> FindAllEnemies(WaveController controller)
    {
        List<GameObject> enemies = new List<GameObject>();

        foreach (EnemySpawner spawner in controller.spawners)
        {
            foreach (Transform child in spawner.transform)
                enemies.Add(child.gameObject);
        }

        return enemies;
    }
    

    // Update is called once per frame
    void Update()
    {
        MultiplayerSceneProperties multiplayerProperties = MultiplayerSceneProperties.Instance;

        // Disable enemy spawning, until both players have connected..
        if (!gameStarted)
        {

            GameManager.gameManager.gameStartCounter = 5;

            if (!isGameManagerInitialized)
            {
                OverrideGameManagerPlayersDiscovery();
                isGameManagerInitialized = true;
            }

            // Start multiplayer enemy spawning only after both players have connected..
            if (multiplayerProperties.currentPlayerList.Count == 2)
            {
                GameObject p1Obj = multiplayerProperties.players[0].second;
                GameObject p2Obj = multiplayerProperties.players[1].second;

                if (p1Obj != null && p2Obj != null)
                {
                    if (p1Obj.GetComponent<NetworkPlayer>().isReady && p2Obj.GetComponent<NetworkPlayer>().isReady)
                        TriggerMultiplayerStart();
                }
            }
        }
        
        // Try to process the update ques
        multiplayerProperties.TransformsUpdateQue.Lock = true; // Lock transform update que's async running.. THIS IS FUCKING DISQUSTING AND DUMB!
        multiplayerProperties.ActionsQue.Lock = true;
        multiplayerProperties.VariablesQue.Lock = true;

        // If current transform update que haven't been processed yet? -> do that
        if (!multiplayerProperties.TransformsUpdateQue.Processed)
        {
            ApplyTransformUpdateQue();
            multiplayerProperties.TransformsUpdateQue.Processed = true;
        }
        multiplayerProperties.TransformsUpdateQue.Lock = false; // Allow transform update que to be set async

        // Update player actions..
        if (!multiplayerProperties.ActionsQue.Processed)
            ApplyActionQue();

        multiplayerProperties.ActionsQue.Lock = false; // Allow actions update que to be set async

        // Update server variables..
        if (!multiplayerProperties.VariablesQue.Processed)
        {
            Random.InitState(multiplayerProperties.VariablesQue.RandomSeed); // Set random seed, generated by the server..
            multiplayerProperties.VariablesQue.Processed = true;
        }

        multiplayerProperties.VariablesQue.Lock = false; // Allow server variables update que to be set async


        // Spawn all non spawned players, if we need to...
        if (ShouldUpdateLocalPlayersList)
        {
            for (int i = 0; i < multiplayerProperties.currentPlayerList.Count; i++)
                multiplayerProperties.AssignNewPlayer(i);
            
            ShouldUpdateLocalPlayersList = false;
        }
    }

    private void LateUpdate()
    {
        // We need to "enable continuous broadcasting" for the client on the server side, by sending a single "transfrom message"
        if (!MultiplayerSceneProperties.Instance.updatedOnce)
        {
            Client client = Client.Instance;
            Package p = new Package(client.RoomId, client.Id, NetworkingCommon.MESSAGE_TYPE__StorePlayerTransform, transform);
            client.SendData(p.Buffer.Bytes);
            MultiplayerSceneProperties.Instance.updatedOnce = true;
        }

        if (isExiting)
            ResetMultiplayer();
    }


    // Checks MultiplayerSceneProperties's transform update que.
    // Applies the transforms we acquired from the server to each player.
    // Detects new players, we need to spawn locally from the transform update que.
    // Detects disconnected users, we needs to destroy locally.
    private void ApplyTransformUpdateQue()
    {
        TransformUpdateQue tuq = MultiplayerSceneProperties.Instance.TransformsUpdateQue;
        MultiplayerSceneProperties sceneProps = MultiplayerSceneProperties.Instance;

        ref List<byte> prevPlayerList = ref sceneProps.previousPlayerList;
        ref List<byte> currentPlayerList = ref sceneProps.currentPlayerList;
        currentPlayerList.Clear();
        if (tuq.userIDs != null)
        {
            // Go through every userID in the transform update que
            // If we can find player with that userID -> update its' transform
            // If we cannot find -> it means this is a new player -> spawn that player
            for (int i = 0; i < tuq.userIDs.Length; i++)
            {
                byte userID = tuq.userIDs[i];
                Pair<byte, GameObject> player = sceneProps.players.Find(x => x.first == userID);
                if (player != null) 
                {
                    // If player was found -> update its' transform
                    if (player.second != null && userID != Client.Instance.Id) // * Also don't get local player's transform from the server..
                    {
                        NetworkPlayer networkPlayer = player.second.GetComponent<NetworkPlayer>();
                        networkPlayer.SetTransform(tuq.positions[i], tuq.rotations[i]);
                        // Also tag this player "ready", so we can in sync trigger game start
                    }
                }
                else
                {
                    // If couldnt find this player -> it means we got a new player -> spawn it
                    sceneProps.AddPlayerSlot(userID);
                    ShouldUpdateLocalPlayersList = true;
                }
                currentPlayerList.Add(userID);
            }
        }
        // Compare current and previous userID lists
        // -> Attempt to find disconnected users and destroy them
        foreach (byte prevListUserID in prevPlayerList)
        {
            if (currentPlayerList.Find(x => x == prevListUserID) == 0)
                sceneProps.DestroyPlayer(prevListUserID);
        }

        prevPlayerList = new List<byte>(currentPlayerList);
    }


    void ApplyActionQue()
    {
        MultiplayerSceneProperties multiplayerProperties = MultiplayerSceneProperties.Instance;
        PlayerActionQue paq = multiplayerProperties.ActionsQue;
        if (paq.userIDs == null)
            return;

        while(paq.userIDs.Count > 0)
        {
            byte userID = 0;
            PlayerActionQue.PlayerActions action = PlayerActionQue.PlayerActions.None;
            weapon attackWeapon = weapon.empty;
            
            paq.Pop(ref userID, ref action, ref attackWeapon);

            if (action == PlayerActionQue.PlayerActions.Attack)
            {
                GameObject playerObj = multiplayerProperties.GetPlayer(userID).second;
                if (playerObj != null)
                {
                    GunController gun = playerObj.GetComponent<NetworkPlayer>().gunController;
                    if (gun != null)
                    {
                        gun.Shoot_local(attackWeapon);
                    }
                }
            }
        }
    }


    private void TriggerMultiplayerStart()
    {
        GameManager.gameManager.SetPlayerCount(2);
        gameStarted = true;
    }

    // To override gameManager's Update()'s players list updating etc..
    private void OverrideGameManagerPlayersDiscovery()
    {
        GameManager gameManager = GameManager.gameManager;

        bool hostChoseBig = false;
        gameManager.SetPlayerCount(2);

        gameManager.playerOne = GameObject.FindGameObjectWithTag("PlayerOne");
        gameManager.cameraOne = gameManager.playerOne.transform.GetChild(0).gameObject;
        gameManager.cameraOnePosition = gameManager.cameraOne.transform.localPosition;

        // Increase this twice for 2 players
        if (gameManager.players.Count > 0)
            gameManager.players.Clear();

        gameManager.AddToPlayersList(); 
        gameManager.AddToPlayersList();

        gameManager.players[0].ammos = new int[2];
        if (!hostChoseBig)
        {
            gameManager.playerOne.transform.GetChild(0).GetComponent<GrapplingHook>().enabled = true;
            gameManager.playerOne.transform.GetChild(0).GetComponent<RocketPack>().enabled = false;
            gameManager.playerOne.GetComponent<AnimatorController>().UsingDukeSprite();
            gameManager.grapplingOrRocketOne = 0;
        }
        else
        {
            gameManager.playerOne.transform.GetChild(0).GetComponent<RocketPack>().enabled = true;
            gameManager.playerOne.transform.GetChild(0).GetComponent<GrapplingHook>().enabled = false;
            gameManager.playerOne.GetComponent<AnimatorController>().UsingAssistantSprite();
            gameManager.grapplingOrRocketOne = 1;
        }

        gameManager.playerTwo = GameObject.FindGameObjectWithTag("PlayerTwo");
        gameManager.cameraTwo = gameManager.playerTwo.transform.GetChild(0).gameObject;
        gameManager.cameraTwoPosition = gameManager.cameraTwo.transform.localPosition;
        gameManager.players[1].ammos = new int[2];
        if (hostChoseBig)
        {
            gameManager.playerTwo.transform.GetChild(0).GetComponent<GrapplingHook>().enabled = true;
            gameManager.playerTwo.transform.GetChild(0).GetComponent<RocketPack>().enabled = false;
            gameManager.playerTwo.GetComponent<AnimatorController>().UsingDukeSprite();
            gameManager.grapplingOrRocketTwo = 0;
        }
        else
        {
            gameManager.playerTwo.transform.GetChild(0).GetComponent<RocketPack>().enabled = true;
            gameManager.playerTwo.transform.GetChild(0).GetComponent<GrapplingHook>().enabled = false;
            gameManager.playerTwo.GetComponent<AnimatorController>().UsingAssistantSprite();
            gameManager.grapplingOrRocketTwo = 1;
        }

        if (gameManager.playerOne.transform.parent.gameObject.GetComponent<NetworkPlayer>().isLocalPlayer)
        {
            UIManager.grapplingHook = true;
            UIManager.rocketPack = false;
        }
        else
        {
            UIManager.grapplingHook = false;
            UIManager.rocketPack = true;
        }

        gameManager.playersFound = true;
    }

    public void ExitMultiplayerScene()
    {
        isExiting = true;
    }

    private void ResetMultiplayer()
    {
        MultiplayerSceneProperties multiplayerProperties = MultiplayerSceneProperties.Instance;
        if (multiplayerProperties.isServerCreator)
        {
            Process serverProcess = multiplayerProperties.serverProcess;
            if (serverProcess != null)
                serverProcess.Kill();
        }

        isGameManagerInitialized = false;
        Client.Instance.DisconnectFromServer();
        multiplayerProperties.Reset();
        Destroy(GameManager.gameManager);
    }
}
